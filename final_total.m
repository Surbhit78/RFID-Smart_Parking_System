%This is the main program file for "RFID-based Smart Parking Management
%System". This file contains the topology and the function calls to other
%functions. 

clear all;
clc;

tag_x = zeros;      % Define the x coordinate for the tags as a zero array
tag_y = zeros;      % Define the y coordinate for the tags as a zero array
reader_x = zeros;   % Define the x coordinate for the readers as a zero array
reader_y = zeros;   % Define the y coordinate for the readers as a zero array
freq = 13.5*10^6;   % Operating frequency
lambda = physconst('LightSpeed')/freq; % Corresponding wavelength
results = [];       % The time taken for the entire program to run 
N = 30;             % The size for the topology => It is a 30X30 of each box of 3m by 5m
output = zeros();
Ra = 1;             % Source Reader Index
Rb = 1;             % Receiver Reader Index, Here it is 1 since we are relaying the data back to the source to check max distance
k = 1;              
j = 1;
m = 1;
% Takes x and y coordinates and maps them to the index of the reader and tag, uses
% the coordinate_function function for operation
reader_index = zeros;   
tag_index = zeros;
% Defines gain and backscatter gain values for different values for reader and tag
G = Gain_values(N,N^2);         
K = Backscatter_gain_values(N,N^2);

P_th = 3.1623*10^(-5);  % Threshold value for receiver power
T = 703;            % Tag under observation

direct_array = [Ra,T,Rb];   % Considers direct communication from source reader, to tag and then to receiver reader

% Dimensions of the space for the car
a = 3; % Average width of a car is 1.81 
b = 5; % Average length of a car is 4.83

% Defines x and y coordinates for the tags
for m = 2:N-1
    for n = 1:2:2*N
        tag_x(m) = a/2 + a*(m-1);
        tag_y(n) = b/2 + b*(n-1);
    end
end
% Omit the values which are zeros (corresponding to the readers)
tag_x = tag_x(tag_x~=0);
tag_y = tag_y(tag_y~=0);
% Defines x and y coordinates for the readers
for m = 1:N-1:N
    for n = 1:2:2*N
        reader_x(m) = a/2 + a*(m-1);
        reader_y(n) = b/2 + b*(n-1);
    end
end
% Omit the values which are zeros (corresponding to the tags)
reader_x = reader_x(reader_x~=0);
reader_y = reader_y(reader_y~=0);
% Calls the buildMatrix function which calculates the weights corresponding
% to each reader and tag, based on values from the Gain and Backscatter
% gain values from the corresponding functions
randomMatrix = buildMatrix(N);
tic;        % Timer starts
% Gives output of bellman ford algorithm from Source Reader to Desired Tag
% and then to the receiver reader
bellman_output_array1 = bellmanford_code(randomMatrix, Ra, T);  
bellman_output_array2 = bellmanford_code(randomMatrix, T, Rb);
bellman_output_array2 = bellman_output_array2(2:length(bellman_output_array2));


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
k = 1;
m = 1;
s1 = length(reader_x);
s2 = length(reader_y);
s = s1*s2;
reader_output = zeros([s 2]);
% Calculation of reader indices
for i = 1:s
    if mod(i,2) ~= 0
        output_index(i) = k + N*(i-j);
        j = j+1;
    else
        output_index(i) = N*(i-m);
        m = m+1;
    end
end
reader_index = output_index';
% Finding x and y coordinates corresponding to given index of the reader
for j = 1:s2
    for i = 1:s1
        reader_output(reader_index(k),:) = [coordinate_function(reader_x(i),reader_y(j))];
        k = k+1;
    end
end
% Calculation of tag indices
s1 = length(tag_x);
s2 = length(tag_y);
s = s1*s2;
tag_output = zeros([s 2]);
k = 1;
for i = 2:N^2
    for j = 1:length(output_index)
        if (i ~= output_index(:))
            tag_index(i) = i;
        end
    end
    k = k+1;
end
tag_index = tag_index(tag_index~=0);
tag_index = tag_index';
k = 1;
% Finding x and y coordinates corresponding to given index of the tag
for j = 1:s2
    for i = 1:s1
        tag_output(tag_index(k),:) = [coordinate_function(tag_x(i),tag_y(j))];
        k = k+1;
    end
end
tag_output(end+1,:) = 0;
final_output = zeros([N^2 2]);
for i = 1:N^2
    final_output(i,:) = reader_output(i,:) +  tag_output(i,:);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Gives Required Source Reader's power for threshold for given
% direct configuration
P_Ra_direct = Power_calculation(P_th, lambda, G, K, direct_array, final_output)
% Gives Required Source Reader's power for threshold for given
% configuration resulting from the shortest path generated by the
% Bellman-Ford Algorithm
bellman_output_array = horzcat(bellman_output_array1, bellman_output_array2)
P_Ra_multi_hop = Power_calculation(P_th, lambda, G, K, bellman_output_array, final_output)
% Total distance corresponding to the direct path and the shortest path by
% Bellman-Ford Algorithm
direct_distance = distances(direct_array,final_output)
end_to_end_dist = distances(bellman_output_array,final_output)
BellmanTime = toc;  % Stops timer
results = n;
results = BellmanTime;
results             % Display timer result